=================== Getting started with node JS=======================
1) Defination:
Node.js is an open-source, cross-platform JavaScript runtime environment that allows developers to run JavaScript on the server side. It uses the V8 JavaScript engine, which is the same engine used by Google Chrome. Node.js is designed for building scalable network applications, particularly those that require real-time interactions, such as chat applications, gaming servers, and collaborative tools.

2) Event-driven:
Event-driven architecture is a design where the flow of a program is controlled by events. An event can be anything from a user action, like a mouse click, to a message from another program.

### Key Points:

1. **Event**: Something that happens (e.g., a button click).
2. **Event Emitter**: The part that generates the event.
3. **Event Listener**: The part that waits for and responds to the event.
4. **Callback**: The function that runs when the event happens.

### How It Works:

1. **Listen**: You set up an event listener to wait for an event.
2. **Emit**: An event occurs, triggering the event emitter.
3. **Respond**: The listener detects the event and runs the callback function.

### Example:

In a web page:

```javascript
button.addEventListener('click', () => {
  alert('Button clicked!');
});
```

In Node.js:

```javascript
const EventEmitter = require('events');
const emitter = new EventEmitter();

emitter.on('event', () => {
  console.log('An event occurred!');
});

emitter.emit('event');
```

### Pros:

- **Responsive**: Good for real-time applications.
- **Flexible**: Can handle many different events easily.

### Cons:

- **Complex**: Can become hard to manage with many events.
- **Performance**: Can be slower due to the overhead of handling events.


3) Pros and cons:
### Pros of Node.js:

1. **Asynchronous and Event-Driven**: Node.js uses an event-driven, non-blocking I/O model, which makes it efficient and suitable for real-time applications.
2. **Fast Performance**: The V8 engine compiles JavaScript to native machine code, making execution extremely fast.
3. **Single Programming Language**: Developers can use JavaScript for both client-side and server-side scripting, leading to a more unified development experience.
4. **Rich Ecosystem**: With npm (Node Package Manager), Node.js has a vast library of packages and modules, which can significantly speed up development.
5. **Scalability**: Node.js is designed for scalability, supporting microservices and real-time applications.
6. **Large Community**: A large and active community provides support, tutorials, and shared resources, making it easier to find help and collaborate.
7. **Cross-Platform**: Node.js can run on various platforms, including Windows, macOS, and Linux, providing flexibility in deployment.

### Cons of Node.js:

1. **Single-Threaded Limitations**: Node.js is single-threaded, which can be a drawback for CPU-intensive tasks. While it handles I/O operations well, it may struggle with heavy computational tasks.
2. **Callback Hell**: The extensive use of callbacks can lead to complex and hard-to-maintain code, often referred to as "callback hell." Promises and async/await have mitigated this issue to some extent.
3. **Maturity of Libraries**: Some npm packages may not be as mature or well-maintained as libraries in other ecosystems, leading to potential security risks or bugs.
4. **Error Handling**: Error handling in asynchronous code can be tricky and may require additional effort to manage effectively.
5. **Tooling and Debugging**: While tooling and debugging support has improved, it may not be as robust as in more established languages and frameworks.
6. **Concurrency Issues**: While Node.js is good at handling multiple concurrent connections, it may not be the best choice for applications that require heavy parallel processing.


4) Hash function in nodeJS:
A hash function in JavaScript is a function that takes an input (or "message") and returns a fixed-size string of bytes. The output is typically a "digest" that is unique to each unique input, making it useful for various applications like data lookup, cryptography, and more.

Here’s an example of a simple hash function using the built-in `crypto` module in Node.js:

### Using Node.js `crypto` Module

```javascript
const crypto = require('crypto');

function hashString(str) {
  return crypto.createHash('sha256').update(str).digest('hex');
}

const myString = "Hello, world!";
const hashedString = hashString(myString);

console.log(hashedString);
```

In the example above:
- `crypto.createHash('sha256')` creates a hash object using the SHA-256 algorithm.
- `.update(str)` updates the hash object with the input string.
- `.digest('hex')` computes the hash and returns it as a hexadecimal string.

### Using Browser JavaScript (without Node.js)

For hashing in the browser, you can use the Web Crypto API, which is available in modern browsers:

```javascript
async function hashString(str) {
  const encoder = new TextEncoder();
  const data = encoder.encode(str);
  const hashBuffer = await crypto.subtle.digest('SHA-256', data);
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  const hashHex = hashArray.map(byte => byte.toString(16).padStart(2, '0')).join('');
  return hashHex;
}

const myString = "Hello, world!";
hashString(myString).then(hashedString => console.log(hashedString));
```

In the example above:
- `TextEncoder` encodes the string into a `Uint8Array`.
- `crypto.subtle.digest('SHA-256', data)` computes the SHA-256 hash.
- The result is converted to a hexadecimal string for easy readability.

### Simple Custom Hash Function

For educational purposes, here’s a simple (but not cryptographically secure) hash function in JavaScript:

```javascript
function simpleHash(str) {
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    const char = str.charCodeAt(i);
    hash = (hash << 5) - hash + char;
    hash |= 0; // Convert to 32bit integer
  }
  return hash;
}

const myString = "Hello, world!";
const hashedString = simpleHash(myString);

console.log(hashedString);
```

This function:
- Iterates over each character in the string.
- Uses bitwise operations to compute a simple hash.

### Note

-- For security-sensitive applications, always use well-established libraries and algorithms like SHA-256 provided by the `crypto` module or Web Crypto API. Simple custom hash functions are generally not suitable for secure hashing. 
-- Decoding a hash function output to retrieve the original input is generally not possible. This is by design, as hash functions are intended to be one-way functions. Once data has been hashed, it cannot be easily reversed. Hash functions like MD5, SHA-1, and SHA-256 are specifically designed to be irreversible.


5) Middleware:
Middleware is software that acts as a bridge between different parts of an application or between different applications. In web development, middleware typically refers to functions that process requests and responses in a web server or application framework before they reach the final handler or after they leave it. Middleware can perform a variety of tasks, such as logging, authentication, error handling, and data parsing.

### Key Points About Middleware:

1. **Intermediary**: Middleware functions operate between the client request and the server response, performing actions on the request and/or response objects.
2. **Reusable**: Middleware can be used across multiple routes and applications, making it a reusable component.
3. **Chaining**: Middleware functions can be chained together to handle requests in a sequential manner. Each middleware function can pass control to the next middleware in the stack.

### How Middleware Works:

When a request is received by the server, it passes through a series of middleware functions before reaching the final request handler. Each middleware function can modify the request or response, perform operations, and decide whether to pass control to the next function in the chain or end the response.

### Example in Express.js (a popular Node.js framework):

#### Logging Middleware Example

```javascript
const express = require('express');
const app = express();

// Middleware function to log request details
function logRequests(req, res, next) {
  console.log(`${req.method} ${req.url}`);
  next(); // Pass control to the next middleware
}

app.use(logRequests);

app.get('/', (req, res) => {
  res.send('Hello, world!');
});

app.listen(3000, () => {
  console.log('Server is running on port 3000');
});
```

In this example:
- `logRequests` is a middleware function that logs the request method and URL.
- `app.use(logRequests)` adds this middleware to the application, so it runs for every incoming request.
- The `next()` function is called to pass control to the next middleware or route handler.

### Types of Middleware:

1. **Application-Level Middleware**: Bound to an instance of `express` using `app.use()` or `app.METHOD()`.
   
   ```javascript
   app.use((req, res, next) => {
     console.log('Application-level middleware');
     next();
   });
   ```

2. **Router-Level Middleware**: Bound to an instance of `express.Router()`, used for modularizing the application.
   
   ```javascript
   const router = express.Router();
   
   router.use((req, res, next) => {
     console.log('Router-level middleware');
     next();
   });
   
   app.use('/route', router);
   ```

3. **Error-Handling Middleware**: Defined with four arguments and used to handle errors in the application.
   
   ```javascript
   app.use((err, req, res, next) => {
     console.error(err.stack);
     res.status(500).send('Something broke!');
   });
   ```

4. **Built-in Middleware**: Provided by Express, such as `express.static` for serving static files and `express.json` for parsing JSON payloads.
   
   ```javascript
   app.use(express.json());
   app.use(express.static('public'));
   ```

5. **Third-Party Middleware**: Middleware provided by third-party libraries, such as `morgan` for logging or `cors` for enabling Cross-Origin Resource Sharing.
   
   ```javascript
   const morgan = require('morgan');
   app.use(morgan('tiny'));
   ```


6) REPL in node:
REPL stands for Read-Eval-Print Loop. It is an interactive shell that processes single lines of input, evaluates them, and returns the result to the user. Node.js includes a built-in REPL that allows you to execute JavaScript code in a command-line environment interactively. This is useful for experimenting with code snippets, debugging, and learning.

To start the REPL, simply type node in your terminal and press Enter:
```
$ node```
You will see a prompt (>) where you can start typing JavaScript code.